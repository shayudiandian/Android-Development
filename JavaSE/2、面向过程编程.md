# 面向过程编程

Java语言是一门【面向对象】的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。



## Java程序基础

### 程序代码基本结构

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。

首先创建的源文件名称需要为`Main.java`

注意需要区分大小写，Java语言严格区分大小写。注意花括号是成对出现的，一一对应。



```java
public static void main(String[] args) {
    
}
```

这是我们整个Java程序的入口点，称为主方法（学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。

比如之前编写的：

```java
System.out.println("Hello World!");
```

这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个`;`符号，表示这一句代码结束。每一段代码结束时都需要加上一个分号表示这一句的结束。



比如下面的代码，就可以实现先打印Hello World!，然后再打印YYDS!到控制台。

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        System.out.println("YYDS!");
    }
}
```

如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：

再比如下面的代码：

```java
    public static void main(String[] args) {
        System.out.
                println("Hello World");
    }
```

```java
    public static void main(String[] args) {
        System.out.          println("Hello World");
    }
```

这里尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，一般不会随意进行换行编写或者是添加没必要的空格。

同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：

```java
    public static void main(String[] args) {
        System.out.println("Hello World");System.out.println("YYDS");
    }
```

如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。



### 注释

单行注释

```java
// XXX
```

多行注释

```java
/*
      这里面的内容
      无论多少行
      都可以
*/
```

当然还有一种方式就是使用`/**`来进行更加详细的文档注释：

```java
/**
 * @author XXX
 *
 */
```

这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。

当然在 Java 23 之后，也可以使用三斜杠来表示这是一个Markdown格式的注释：

```java
/// # 这个是主类
/// - 主类是执行程序的入口
/// - 主类里面有主方法
public class Main {
    
}
```





### 变量与常量

要声明一个变量，需要使用以下格式：

```java
[数据类型] [变量名称];
```

注意要满足以下要求：

- 标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。
- 变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。
- 不能有空格、@、#、+、-、/ 等符号。
- 应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。
- 不可以是 true 和 false。
- 不能与Java语言的关键字或是基本数据类型重名，关键字列表如下：

| **abstract** | **assert**       | **boolean**  | **break**     | **byte**     | **case**      | **catch**  | **char**       |
| ------------ | ---------------- | ------------ | ------------- | ------------ | ------------- | ---------- | -------------- |
| **class**    | **const**        | **continue** | **default**   | **do**       | **double**    | **else**   | **enum**       |
| **extends**  | **final**        | **finally**  | **float**     | **for**      | **goto**      | **if**     | **implements** |
| **import**   | **instanceof**   | **int**      | **interface** | **long**     | **native**    | **new**    | **package**    |
| **private**  | **protected**    | **public**   | **return**    | **strictfp** | **short**     | **static** | **super**      |
| **switch**   | **synchronized** | **this**     | **throw**     | **throws**   | **transient** | **try**    | **void**       |
| **volatile** | **while**        |              |               |              |               |            |                |





 想要定义一个变量`a`，那么就可以这样编写：

```java
public class Main {
    public static void main(String[] args) {
        int a;    //声明一个整数类型变量a
    }
}
```

但是这个变量一开始没有任何值，现在要让这个变量表示10，那么就可以将10赋值给这个变量：

```java
public static void main(String[] args) {
    int a = 10;   //直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字
}
```

或者可以在使用时再对其进行赋值：

```java
public static void main(String[] args) {
    int a;
    a = 10;   //使用时再赋值也可以
}
```

可以一次性定义多个变量，比如现在想定义两个`int`类型的变量：

```java
public static void main(String[] args) {
    int a, b;   //定义变量a和变量b，中间使用逗号隔开就行了
}
```

或者两个变量单独声明也可以：

```java
public static void main(String[] args) {
    int a;   //分两句进行声明
    int b;
}
```

为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：

```java
public static void main(String[] args) {
    int a = 666;
    System.out.println(a);    //之前我们在小括号写的是""，现在我们直接将变量给进去就可以打印变量的值了
  	System.out.println(888);   //甚至直接输出一个常量值都可以
}
```

变量的值也可以在中途进行修改：

```java
public static void main(String[] args) {
    int a = 666;
    a = 777;
    System.out.println(a);   //这里打印得到的值就是777了
}
```

变量的值也可以直接指定为其他变量的值：

```java
public static void main(String[] args) {
    int a = 10;
    int b = a;   //直接让b等于a，那么a的值就会给到b
    System.out.println(b);   //这里输出的就是10了
}
```

还可以让变量与数值之间做加减法：

```java
public static void main(String[] args) {
    int a = 9;   //a初始值为9
    a = a + 1;   //a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧
    System.out.println(a);   //最后得到的结果就是10了
}
```

有时候希望变量的值一直保持不变，我们就可以将其指定为常量，使用关键字 final：

```java
public static void main(String[] args) {
    final int a = 666;   //在变量前面添加final关键字，表示这是一个常量
    a = 777;    //常量的值不允许发生修改，编译错误
}
```

常量的值只有第一次赋值可以修改，其他任何情况下都不行：

```java
public static void main(String[] args) {
    final int a;
    a = 777;   //第一次赋值
}
```





***

## 基本数据类型

### 计算机中的二进制表示

在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为计算机是电子的，电平信号只有高位和低位，可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。

111 = 7

注意小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。

> 十进制的7 -> 在二进制中为 111 = 2^2 + 2^1 + 2^0

现在有4个bit位，最大能够表示多大的数字呢？

- 最小：0000 => 0
- 最大：1111 => 23+22+21+20 => 8 + 4 + 2 + 1 = 15

在Java中，无论是小数还是整数，他们都要带有符号（C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：

- 最小：1111 => -(2^2 + 2^1 + 2^0) => -7
- 最大：0111 => +(2^2 + 2^1 + 2^0) => +7 => 7

现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为**原码**。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：

> 1+(-1) = 0001 + 1001 = 怎么让计算机去计算？

于是引入了**反码**：

- 正数的反码是其原码本身 
- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反

经过上面的定义，再来进行加减法：

> 1+(-1) = 0001 + 1110 = 1111 => -0

思考：1111代表-0，0000代表+0，在实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，引入了**补码**，定义如下：

- 正数的补码是其原码本身 
- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1）
- 对补码再求一次补码就可得该补码对应的原码。

比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。

所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：

> 1+(-1) = 0001 + 1111 = (1)0000 => +0 （现在无论怎么算，也不会有-0了！）

所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）



### 整数类形

在Java中，整数类型包括以下几个：

- byte 字节型 （8个bit，1个字节）范围：-128~+127
- short 短整形（16个bit，2个字节）范围：-32768~+32767
- int 整形（32个bit，4个字节）最常用的类型：-2147483648 ~ +2147483647
- long 长整形（64个bit，8个字节）范围：-9223372036854775808 ~ +9223372036854775807

这里我们来使用一下，其实这几种变量都可以正常表示整数：

```java
public static void main(String[] args) {
    short a = 10;
    System.out.println(a);
}
```

因为都可以表示整数，所以可以将小的整数类型值传递给大的整数类型：

```java
public static void main(String[] args) {
    short a = 10;
    int b = a;   //小的类型可以直接传递给表示范围更大的类型
    System.out.println(b);
}
```

反之会出现报错：

```java
int a = 10;
short b = a;   // 编译错误
```

这是由于在将小的整数类型传递给大的整数类型时发生了**隐式类型转换**，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。

隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间。

实际上在为变量赋一个常量数值时，也发生了隐式类型转换，比如：

```java
public static void main(String[] args) {
   byte b = 10;    //这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值
}
```

由于直接编写的整数常量值默认为`int`，这里需要特别注意一下，比如下面这种情况：

```java
long a = 922337203685477580;      // 编译错误
```

按照`long`类型的规定实际上是可以表示这么大的数字的。为什么这里报错了呢？这是因为直接在代码中写的常量数字，默认情况下就是`int`类型，`int`表示不下，如果需要将其表示为一个`long`类型的常量数字，那么需要在后面添加`l`或`L`才可以。

```java
long a = 922337203685477580L;     // 编译通过
```

当然，针对于这种很长的数字，为了提升辨识度，可以使用下划线分割每一位：

```java
public static void main(String[] args) {
   int a = 1_000_000;    //当然这里依然表示的是1000000，没什么区别，但是辨识度会更高
}
```

也可以以8进制或是16进制表示一个常量值：

```java
System.out.println(0xA);
System.out.println(012);
```

* **十六进制：** 以`0x`开头的都是十六进制表示法，十六进制满16进一，但是由于只提供了0-9这十个数字，10、11、12...15使用英文字母A按照顺序开始表示，A表示10、B表示11...F表示15。比如上面的0xA实际上就是我们十进制中的10。
* **八进制：** 以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。



溢出问题

```java
int a = 2147483647;   //int最大值
a = a + 1;   //继续加

// a = -2147483648
```

当int为最大值时，二进制表示形式为：

* 2147483647 = 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值）

那么此时如果加1，会进位成：

* 10000000 00000000 00000000 00000000

各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？这就是补码形式下的最小值

所以说最后的结果就是`int`类型的最小值：-2147483648。





### 浮点类型

Java中的小数类型包含：

- float 单精度浮点型 （32bit，4字节）
- double 双精度浮点型（64bit，8字节）

那么小数在计算机中又是如何存放的呢？

float 单精度实数的存储结构：

```
S(31)      E(阶码，30~23，共8位)         M（尾数，22~0，共23位）
```

double 双精度实数的存储结构：

```
S(63)      E(阶码，52~62，共11位)         M（尾数，51~0，共52位）
```

根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：
$$
V = (-1)^S \times M \times 2^E
$$

* $(-1)^S$ 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。
* M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）
* $2^E$ 表示指数位（用于移动小数点，所以说才称为浮点型），指数默认存储需要添加127的偏移量，便于同时处理正负指数的情况。

比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \times 2^2$。所以，S 为 0，M 为 0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：

* 单精度：$±3.40282347 \times 10^{38}$
* 双精度：$±1.79769313486231570 \times 10^{308}$



可以直接创建浮点类型的变量：

```java
public static void main(String[] args) {
    double a = 10.5, b = 66;   //整数类型常量也可以隐式转换到浮点类型
}
```

注意，跟整数类型常量一样，小数类型常量默认都是`double`类型，所以说如果我们直接给一个float类型赋值：

```java
float a = 9.9;          // 编译错误
```

由于`float`类型的精度不如`double`，如果直接给其赋一个double类型的值，会直接出现错误。

同样的，可以给常量后面添加`f`或`F`来表示这是一个`float`类型的常量值：

```java
float f = 9.9F;         // 编译通过
```

但是反之，由于`double`精度更大，所以说可以直接接收`float`类型的值：

```java
float f = 9.9F;
double a = f;    // 隐式类型转换为double值
```

只不过由于精度问题，最后的打印结果：

```java
9.899999618530273
```

这种情况是正常的，因为浮点类型并不保证能够精确计算。



隐式转换

```java
public static void main(String[] args) {
    long l = 21731371236768L;
    float f = l;   // 这里能编译通过吗？
    System.out.println(f);
}
```

此时发现，`long`类型的值居然可以直接丢给`float`类型隐式类型转换，很明显`float`只有32个bit位，而`long`有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然`float`空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于`long`类型的，虽然会丢失精度，但是确实可以表示这么大的数。



总结一下【隐式类型转换规则】：byte→short(char)→int→long→float→double





### 字符类型

字符类型可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）

- char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535

可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：

比如我们的英文字母`A`要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：

```java
public static void main(String[] args) {
    char c = 65;
    System.out.println(c);       // A
}
```

或者也可以直接写一个字符常量值赋值：

```java
public static void main(String[] args) {
    char c = 'A';    //字符常量值需要使用单引号囊括，并且内部只能有一个字符
    System.out.println(c);
}
```

这种写法效果与上面是一样的。



不过，字符表里面不就128个字符吗，那`char`干嘛要两个字节的空间来存放呢？表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。

> 我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。
>
> 不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。
>
> 虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）
>
> 但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头。
>
> 所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，它最多可以表示4个字节的内容。随着编码规则的演进，后来又有了UTF-16编码格式，采用BMP字符节省空间，它大量对于中文字符的应用效果更好，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。

| Unicode符号范围（十六进制） | UTF-8编码方式(二进制)               |
| --------------------------- | ----------------------------------- |
| 0000 0000 ~ 0000 007F       | 0xxxxxxx                            |
| 0000 0080 ~ 0000 07FF       | 110xxxxx 10xxxxxx                   |
| 0000 0800 ~ 0000 FFFF       | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000 ~ 0010 FFFF       | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

**注意：** Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存。



简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，`char`类型可以直接表示一个中文字符：

```java
public static void main(String[] args) {
    int a = '淦';   //使用int类型接收字符类型常量值可以直接转换为对应的编码
    System.out.println(a);   // 28314
}
```

Java程序在编译为`.class`文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：

```java
int 你干嘛 = 666;
```



char没办法表示多个字符：

```java
char c = '啊这';       // 编译错误
```

可以使用String字符串：

```java
public static void main(String[] args) {
    String str = "啊这";    //字符串需要使用双引号囊括，字符串中可以包含0-N个字符
}
```

`String`类型并**不是基本数据类型**，它是对象类型，后续详细介绍。





### 布尔类型

布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：

* true  -  真
* false  -  假

布尔类型（boolean）只有`true`和`false`两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。

```java
public static void main(String[] args) {
    boolean b = true;   //值只能是true或false
    System.out.println(b);
}
```

如果给一个其他的值，会无法编译通过：

```java
boolean b = 6;     // 编译错误
```





### (Java 10) 局部变量类型推断

Java 10 引入了 `var` 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。

例如我们现在想要创建一个整形变量，我们之前是这样编写的：

```java
int a = 10;
//如果需要改成其他类型，前面的int也得跟着改
```

在Java10之后，可以使用`var`关键字来根据后面的结果自动识别类型：

```java
var a = 10;
```

此时，无论修改后面的变量值为什么类型的值，都可以自动进行推断：

实际上这个特性很多语言都有，Java选择在Java10才上线此功能，有点为时已晚。由于Java社区普遍较为保守，很多开发者在刚推出时倾向于继续使用显式类型声明，特别是在代码稳定性和可读性方面。所以，这种用法在很多项目里面并不常见，这里只做了解即可。





***

## 运算符

### 赋值运算符

赋值运算符可以直接给某个变量赋值：

```java
public static void main(String[] args) {
    int a = 666;   //使用等号进行赋值运算
}
```

**使用规则为：** 赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。

当然，赋值运算符并不只是单纯的赋值，它是有结果的：

```java
public static void main(String[] args) {
    int a;
    int b = a = 777;
}
```

当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是`a = 777`，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为`a = 777`的计算结果，同样的也是 777 了。

所以，使用连等可以将一连串变量都赋值为最右边的值。



### 算术运算符

算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。

```java
public static void main(String[] args) {
    int a = 1 + 1;
    System.out.println(a);
}
```

可以看到a赋值为1+1的结果，所以说最后a就是2了。

当然变量也是可以参与到算术运算中：

```java
public static void main(String[] args) {
    int a = 3;
    int b = a - 10;
    System.out.println(b);
}
```

不同类型之间也可以进行运算：

```java
int a = 5;
short b = 10;
int c = a + b;   
// 使用整数进行运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都会自动转换）结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long。
```

因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：

```java
int a = 5;
short b = 10;
short c = a + b;           // 编译错误
```

小数和整数一起计算同样会发生隐式类型转换：

```java
int a = 5;
float b = 10;
int c = a + b;           // 编译错误
```

因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。



也可以将加减号作为正负符号使用，比如需要让a变成自己的相反数：

```java
public static void main(String[] args) {
    int a = 10;
    a = -a;   //减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数
    System.out.println(a);   //这里就会得到-10了
}
```

同样的，正号也可以使用，但是似乎没什么用：

```java
public static void main(String[] args) {
    int a = 10;
    a = +a;   //正号本身在数学中就是可以省略的存在，所以Java中同样如此
    System.out.println(a);
}
```

注意加法支持对字符串的拼接：

```java
public static void main(String[] args) {
    String str = "伞兵" + "lbw";    // 可以使用加号来拼接两个字符串
    System.out.println(str);       // 伞兵lbw
}
```

字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：

```java
public static void main(String[] args) {
    String str = "伞兵" + true + 1.5 + 'A';
    System.out.println(str);     // 伞兵true1.5A
}
```



当然，除了加减法之外乘除法也是支持的：

```java
public static void main(String[] args) {
    int a = 8, b = 2;
    System.out.println(a * b);   //乘法使用*表示乘号
  	System.out.println(a / b);   //除法就是一个/表示除号
}
```

注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）

```java
public static void main(String[] args) {
    int a = 8, b = 5;
    System.out.println(a / b);     // 1
}
```

上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃。

但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：

```java
public static void main(String[] args) {
    double a = 8.0, b = 5.0;
    System.out.println(a / b);    // 1.6
}
```

同样的，整数和小数一起计算，由于所有的整数范围都比小数小，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：

```java
public static void main(String[] args) {
    double a = 8.0;
    int b = 5;
    System.out.println(a / b);     // 1.6
}
```

现在有两个整数需要进行计算，但是就是希望可以得到一个小数的结果该怎么办呢？

```java
public static void main(String[] args) {
    int a = 8, b = 5;
    double c = a;   //可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算
    System.out.println(c / b);   //同样可以得到正确结果
}
```

后续将介绍强制类型转换，通过使用强制类型转换，可以更轻松地让整数计算出小数的结果。



除了最基本的加减乘除操作，也可以进行取模操作：

```java
public static void main(String[] args) {
    int a = 10;
    System.out.println(a % 3);   //比如这里对a进行取模操作，实际上就是计算除以3的余数
}
```

比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1。

查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：

```java
public static void main(String[] args) {
    System.out.println(17 % 2);   //17不是双数，所以说最后会得到1
}
```



注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：

```java
public static void main(String[] args) {
    System.out.println(10 + 3 * 4);
}
```

上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。总结一下到目前为止所有学习到的运算符相关性质：

| 优先级 |            运算符             | 结合性（出现同优先级运算符时） |
| :----: | :---------------------------: | :----------------------------: |
|   1    |       -(负号)  +(正号)        |            从右向左            |
|   2    |           *   /  %            |            从左往右            |
|   3    | +(加法，包括字符串)   -(减法) |            从左往右            |
|   4    |               =               |            从右向左            |

比如下面的结果：

```java
public static void main(String[] args) {
    int a = 10;
    int b = a = 8 * -a + 10;
    /*
        1. 正负号优先级最高，所有首先计算的是-a，得到-10
        2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80
        3. 然后是加减法，-80 + 10 = -70
        4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70
        5. 最后b就是 -70
     */
    System.out.println(b);
}
```





### 括号运算符

可以通过添加括号的方式来提升某些运算的优先级：

```java
public static void main(String[] args) {
    int a = 10;
    int b = (a = 8) * (-a + 10);
    /*
        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算
        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8
        3. 然后是后面的加法，-a就是-8，加上10就是2
        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16
     */
    System.out.println(b);
}
```

所以，通过添加括号，就可以更加灵活的控制计算。

当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。

在嵌套的情况下，会优先计算最内层括号中的算式：


```java
public static void main(String[] args) {
    int b = (2 + (3 + 1) * 3) * 2;
    System.out.println(b);
}
```

这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3  = 14，最后来到最外层14*2 = 28，计算结束。

括号除了可以用来提升运算优先级，也可以用作**强制类型转换**，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时希望将一个大的类型转换为一个小的类型：

```java
int a = 10;
short b = a;       // 编译错误
```

正常情况下无法编译通过，但是实际上a的值并没有超出`short`的范围，理论上是可以直接给到b存放的，此时可以使用强制类型转换：

```java
short b = (short) a;   // 在括号中填写上强制转换的类型，就可以强制转换到对应的类型了
```

但是强制类型转换存在一定的风险，比如：

```java
public static void main(String[] args) {
    int a = 128;   //已经超出byte的范围了
    byte b = (byte) a;  //此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位
    System.out.println(b);  // -128
}
```

比如这里的128：

* 00000000 00000000 00000000 10000000  ->  byte只有一个字节，所以说只保留最后8位 -> 10000000

这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：-128

所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中。

有了强制类型转换，就可以很轻松地让两个整数计算出小数的结果了：

```java
int a = 8, b = 5;
double c = a/(double)b;  
//强制类型转换的优先级跟正负号一样
//计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了
```

但是下面的情况不可以：

```java
int a = 8, b = 5;
double c = (double) (a/b);
```

括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。



还是来总结一下目前遇到的所有运算符：

| 优先级 |            运算符             |  结合性  |
| :----: | :---------------------------: | :------: |
|   1    |              ( )              | 从左向右 |
|   2    |     -  +  (强制类型转换)      | 从右向左 |
|   3    |           *   /  %            | 从左向右 |
|   4    | +(加法，包括字符串)   -(减法) | 从左向右 |
|   5    |               =               | 从右向左 |





### 自增自减运算符

有时候可能需要让变量自己进行增加操作，比如现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以：

```java
public static void main(String[] args) {
    int a = 8;
    a = a + 1;    //让a等于a本身+1，相当于自增了1
    System.out.println(a);   //9
}
```

也可以使用自增自减运算符：

```java
public static void main(String[] args) {
    int a = 8;
    a++;   //自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1
  	a--;   //自减
    System.out.println(a);
}
```

自增自减运算符可以放到操作数的前后：

```java
public static void main(String[] args) {
    int a = 8;
    ++a;   //自增运算符在前在后最终效果都是让a自增1，是一样的
    System.out.println(a);
}
```

自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样：

```java
public static void main(String[] args) {
    int a = 8;
    int b = a++;   //先出结果，再自增
    System.out.println(b);  //b得到的是a自增前的值 8
}
```

```java
public static void main(String[] args) {
    int a = 8;
    int b = ++a;   //先自增，再出结果
    System.out.println(b);   //b得到的是a自增之后的结果 9
}
```

自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理）

自增自减运算符的优先级与正负号等价比如：

```java
public static void main(String[] args) {
    int a = 8;
    int b = -a++ + ++a; 
  	//首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++
  	//a++的结果还是8，然后是负号，得到-8
  	//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10
  	//最后得到的结果为 -8 + 10 = 2
    System.out.println(b);
}
```

一般情况下，除了考试会出现这种恶心人的写法之外，尽量不要去写这种难以阅读的东西。

当然，有些时候并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外：

```java
a += 4;  // 与a = a + 4效果完全一样
```

不止加法，包括前面介绍的全部算术运算符，都是支持这种缩写的：

```java
a *= 9;   //跟 a = a * 9 等价
```



还是来总结一下目前遇到的所有运算符：

| 优先级 |            运算符             |  结合性  |
| :----: | :---------------------------: | :------: |
|   1    |              ( )              | 从左向右 |
|   2    |  -  +  (强制类型转换)  ++ --  | 从右向左 |
|   3    |           *   /  %            | 从左向右 |
|   4    | +(加法，包括字符串)   -(减法) | 从左向右 |
|   5    |    =  +=  -=  *=   /=   %=    | 从右向左 |





### 位运算符

可以使用位运算符直接以【二进制】形式操作目标，位运算符包括：&    |    ^    ~

先来看【按位与&】，比如下面的两个数：

```java
int a = 9, b = 3;
int c = a & b;
```

按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：

* a = 9 = 1001
* b = 3 = 0011
* c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）

【按位或】，其实就是只要任意一个为1（不能同时为0）那么结果就是1：

```java
int a = 9, b = 3;
int c = a | b;
```

* a = 9 = 1001
* b = 3 = 0011
* c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）

【按位异或】，只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：

```java
int a = 9, b = 3;
int c = a ^ b;
```

* a = 9 = 1001
* b = 3 = 0011
* c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）

【按位取反】，如果这一位上是1，变成0，如果是0，变成1：

```java
byte c = ~127;
```

* 127 = 01111111
* -128 = 10000000

所以说计算的结果就是-128了。



除了以上的四个运算符之外，还有【位移运算符】，比如：

```java
byte c = 1 << 2;    // 左移
```

* 1 = 00000001 
* 4 = 00000100（左移两位之后，1跑到前面去了，尾部使用**0**填充，此时就是4）

左移操作每进行一次，结果就会x2，所以除了直接使用`*`进行乘2的运算之外，我们也可以使用左移操作来完成。

同样的，右移操作就是向右移动每一位：

```java
byte c = 8 >> 2;     // 右移
```

* 8 = 00001000
* 2 = 00000010（右移两位之后，1跑到后面去了，头部使用**符号位数字**填充，此时变成2）

右移操作可以快速进行除以2的计算。

对于<u>负数</u>来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：

```java
byte c = -4 >> 1;
```

* -4   = 11111100
* -2   = 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用**符号位数字**来进行填充）

总结：

* **左移操作<<：** 高位直接丢弃，低位补0
* **右移操作>>：** 低位直接丢弃，符号位是什么高位补什么

也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：

```java
int c = -1 >> 1;   //正常的右移操作，高位补1，所以说移了还是-1
```

```java
int c = -1 >>> 1;   //无符号右移会直接考虑符号位
```

比如：

* -1    =   11111111 11111111 11111111 11111111
* 右移：  01111111 11111111 11111111 11111111（【无符号右移】使用0填充高位）

此时得到的结果就是正数的最大值 2147483647 了，注意，<u>不存在无符号左移</u>。

位移操作也可以缩写：

```java
c <<= 2;    // c = c << 2
```



还是来总结一下目前遇到的所有运算符：

| 优先级 |                          运算符                          |  结合性  |
| :----: | :------------------------------------------------------: | :------: |
|   1    |                           ( )                            | 从左向右 |
|   2    |            ~   -   +  (强制类型转换)  ++   --            | 从右向左 |
|   3    |                         *   /  %                         | 从左向右 |
|   4    |                          +   -                           | 从左向右 |
|   5    |                      <<   >>   >>>                       | 从左向右 |
|   6    |                            &                             | 从左向右 |
|   7    |                            ^                             | 从左向右 |
|   8    |                            \|                            | 从左向右 |
|   9    | =  +=  -=  *=   /=   %=   &=   \|=   ^=   <<=  >>=  >>>= | 从右向左 |





### 关系运算符

可以对某些事物进行判断，比如想判断两个变量谁更大，可以使用关系运算符：

```java
public static void main(String[] args) {
    int a = 10, b = 20;
    boolean c = a > b;   //进行判断，如果a > b那么就会得到true，否则会得到false
}
```

关系判断的结果只可能是真或是假，所以说得到的结果是一个`boolean`类型的值。

关系判断运算符包括：

```
>   大于
<   小于
==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）
!=  不等于
>=  大于等于
<=  小于等于
```





### 逻辑运算符

想要判断a是否小于等于100且大于等于60：

```java
boolean b = 100 >= a >= 60;     // 编译错误
```

为了解决这种问题，可以使用逻辑运算符，包括：

```java
&&     与运算，要求两边同时为true才能返回true
||     或运算，要求两边至少要有一个为true才能返回true
!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转
```

使用逻辑运算符进行复杂条件判断：

```java
boolean b = 100 >= a && a >= 60;
```

与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假。

来看下面的这个例子：

```java
int a = 150;
boolean b = 100 >= a && a >= 60;
```

这个例子中，第一个判断表达式就得到了`false`，此时不会再继续运行第二个表达式，而是直接得到结果`false`（逻辑运算符会出现**短路**的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）

同样的，比如现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系：

```java
int a = 150;
boolean b = a < 0 || a > 10;   //或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false
```

或运算同样会出现短路的情况，比如下面的例子：

```java
int a = -9;
boolean b = a < 0 || a > 10;  //此时上来就满足条件
```

因为第一个判断表达式就直接得到了`true`，那么第二个表达式无论是真还是假，结果都一定是`true`，所以说没必要继续向后进行判断了，直接得到结果`true`。

来看看下面的结果是什么：

```java
int a = 10;
boolean b = a++ > 10 && ++a == 12;
// a = 11 b = false
```

第一个表达式判断的结果为`false`，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。

非运算将结果变成相反的样子，比如：

```java
int a = 10;
boolean b = !(a > 5);   // b = falses
```



**三元运算符**

```java
判断语句 ? 结果1 : 结果2
// 第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值
```

```java
int a = 10;
char b = a > 10 ? 'A' : 'B';         // b = B
```





运算符优先级

| 优先级 |                          运算符                          |  结合性  |
| :----: | :------------------------------------------------------: | :------: |
|   1    |                           ( )                            | 从左向右 |
|   2    |           ! ~   -   +  (强制类型转换)  ++   --           | 从右向左 |
|   3    |                         *   /  %                         | 从左向右 |
|   4    |                          +   -                           | 从左向右 |
|   5    |                      <<   >>   >>>                       | 从左向右 |
|   6    |                     >   <   >=   >=                      | 从左向右 |
|   7    |                        ==     !=                         | 从左向右 |
|   8    |                            &                             | 从左向右 |
|   9    |                            ^                             | 从左向右 |
|   10   |                            \|                            | 从左向右 |
|   11   |                            &&                            | 从左向右 |
|   12   |                           \|\|                           | 从左向右 |
|   13   |                           ? :                            | 从右向左 |
|   14   | =  +=  -=  *=   /=   %=   &=   \|=   ^=   <<=  >>=  >>>= | 从右向左 |





## 流程控制

程序都是从上往下依次运行的，但是，仅仅是这样还不够，需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时就需要用到选择结构来完成条件的判断和程序的分支走向。学习过C语言就很轻松！

可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。

### 代码块与作用域

```java
public class Main {   //外层花括号
    public static void main(String[] args) {   //内层花括号开始
       
    }  //内层花括号结束
}
```

可以在【花括号】中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为**块**（代码块），一个代码块中可以包含多行代码，可以在里面做各种各样的事情，比如定义变量、进行计算等等。

可以自由地创建代码块：

```java
public static void main(String[] args) {
    System.out.println("外层");
    {   //自由创建代码块
        int a = 10;
        System.out.println(a);
    }
}
```

虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。

我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如：

```java
    {   
        int a = 10;
        System.out.println(a);
    }
     System.out.println(a);      // 编译错误
```

变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。

```java
public static void main(String[] args) {
    int a = 10;   //此时变量在最外层定义
    {
        System.out.println(a);   //处于其作用域内部的代码块可以使用
    }
    System.out.println(a);   //这里肯定也可以使用
}
```

我们目前所创建的变量都是局部变量（有范围限制），后面会介绍更多种类型的变量。





### 选择结构

某些时候希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先来认识一下`if`语句：

```java
if (条件判断) 判断成功执行的代码;
```

```java
public static void main(String[] args) {
    int a = 15;
    if (a == 15)    //只有当a判断等于15时，才会执行下面的打印语句
      	System.out.println("Hello World!");
  	System.out.println("我是外层");   //if只会对紧跟着的一行代码生效，后续的内容无效
}
```

`if`会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在`if`中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，以后使用`if`时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括后面会讲到的`else`、`while`、`for`语句都是这样的。

```java
public static void main(String[] args) {
    int a = 15;
    if (a > 10) {    //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过
        System.out.println("a大于10");
        System.out.println("a的值为："+a);
    }
  	System.out.println("我是外层");
}
```

如果希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加`else`语句：

```java
public static void main(String[] args) {
    int a = 15;
    if (a > 10) {    //只有判断成功时，才会执行下面的代码块中内容，否则直接跳过
        System.out.println("a大于10");
        System.out.println("a的值为："+a);
    } else {   //当判断不成功时，会执行else代码块中的代码
        System.out.println("a小于10");
        System.out.println("a的值为："+a);
    }
    System.out.println("我是外层");
}
```

`if-else`语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟之前认识的三元运算符性质比较类似。

那如果需要判断多个分支呢？使用`else-if`来完成：

```java
public static void main(String[] args) {
    int score =  2;
    if (score >= 90)    //90分以上才是优秀
        System.out.println("优秀");
     else if (score >= 70)    //当上一级if判断失败时，会继续判断这一级
        System.out.println("良好");
     else if (score >= 60)
        System.out.println("及格");
     else    //当之前所有的if都判断失败时，才会进入到最后的else语句中
        System.out.println("不及格");
}
```

当然，`if`分支语句还支持嵌套使用：

```java
public static void main(String[] args) {
    int score =  2;
    if (score < 60) {   //先判断不及格
        if(score > 30)    //在内层再嵌套一个if语句进行进一步的判断
            System.out.println("学习C++");
        else
            System.out.println("学习Java");
    }
}
```

除了`if`自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，就可以灵活地使用`if`来进行各种条件判断了。

可以通过一个`if`语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用`switch`语句来实现，它更适用于多分支的情况：

```java
switch (目标) {   //我们需要传入一个目标，比如变量，或是计算表达式等
  case 匹配值:    //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码
    代码...
    break;    //代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码
}
```

比如现在要根据学生的等级进行分班，学生有ABC三个等级：

```java
public static void main(String[] args) {
    char c = 'A';
    switch (c) {  //这里目标就是变量c
        case 'A':    //分别指定ABC三个匹配值，并且执行不同的代码
            System.out.println("去尖子班！准备冲刺985大学！");
            break;   //执行完之后一定记得break，否则会继续向下执行下一个case中的代码
        case 'B':
            System.out.println("去平行班！准备冲刺一本！");
            break;
        case 'C':
            System.out.println("去职高深造。");
            break;
    }
}
```

`switch`可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。

当然除了精准匹配之外，其他的情况我们可以用`default`来表示：

```java
switch (目标) {
    case: ...
    default:
    		其他情况下执行的代码
}
```

```java
public static void main(String[] args) {
    char c = 'A';
    switch (c) {
        case 'A':
            System.out.println("去尖子班！");
            break;
        case 'B':
            System.out.println("去平行班！");
            break;
        case 'C':
            System.out.println("去差生班！");
            break;
        default:   //其他情况一律就是下面的代码了
            System.out.println("去读职高，分流");
    }
}
```

当然switch中可以继续嵌套其他的流程控制语句，比如if：

```java
public static void main(String[] args) {
    char c = 'A';
    switch (c) {
        case 'A':
            if(c == 'A') {    //嵌套一个if语句
                System.out.println("去尖子班！");
            }
            break;
        case 'B':
            System.out.println("去平行班！");
            break;
    }
}
```



### (Java 14) Switch表达式

在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在要给不同分数的学生打等级（学生满分10分）之前学习的传统`switch`语句像这样写：

```java
int score = 9;
char grade;
switch (score) {
    case 10:
    case 9:
        grade = 'A';
        break;
    case 8:
        grade = 'B';
        break;
    case 7:
    case 6:
        grade = 'C';
        break;
    default:
        grade = 'D';
}
System.out.println("学生等级为: " + grade);
```

这是在是太累了，每一种情况都要单独编写`case`和`break`语句，可以使用新的`switch`语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是用做方法返回值使用：

```java
int score = 9;
//直接让grade接受switch的结果
char grade = switch (score) {
    case 10, 9 -> 'A';   //case后面直接使用->来指定返回结果
    case 8 -> 'B';
    case 6, 7 -> 'C';  //当存在多个匹配条件时，使用逗号分隔
    default -> 'D';
};  //别忘了这种写法相当于赋值，最后需要加分号
System.out.println("学生等级为: " + grade);
```

其中`grade`得到的就是每一个`case`语句`->`符号后的结果，不需要任何`break`操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：

```java
var res = switch (obj) {   //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收
    case [匹配值, ...] -> "优秀";   //case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -> 来返回如果匹配此case语句的结果
    case ...   //根据不同的分支，可以存在多个case
    default -> "不及格";   //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的
};
```

不过，有些时候可能并不能直接指定返回的结果，比如存在前置操作的情况下，可以像这样编写：

```java
char grade = switch (score) {
    case 9 -> 'A';
    case 8 -> 'B';
    case 6, 7 -> {
        System.out.println("我是额外操作");   //存在前置操作，无法直接指定结果
        yield 'C';   //在最后使用yield关键字来指定结果
    }
    default -> 'D';
};
```

我们可以使用`yield`关键字来指定延迟返回的结果，同样的，不需要任何`break`操作，分支会自动结束（注意`yield`执行之后，后续不能再有任何代码了，因为已经结束了）

这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。但是注意，箭头语法和传统语法在Java 21之前是不允许混用的，Java 21之后可以相互混用。





### 循环结构

在某些时候，可能需要批量执行某些代码：

```java
public static void main(String[] args) {
    System.out.println("大烟杆嘴里塞，我只抽第五代");   //把这句话给我打印三遍
    System.out.println("大烟杆嘴里塞，我只抽第五代");
    System.out.println("大烟杆嘴里塞，我只抽第五代");
}
```

遇到这种情况，由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么岂不是光CV代码就要搞一下午？

现在，要解决这种问题，我们可以使用for循环语句来多次执行：

```java
for (表达式1;表达式2;表达式3) 循环体;
```

介绍一下详细规则：

- 表达式1：在循环开始时仅执行一次。
- 表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。
- 表达式3：每次循环完成后会执行一次。
- 循环体：每次循环都会执行一次循环体。

一个标准的for循环语句写法如下：

```java
public static void main(String[] args) {
  	//比如我们希望让刚刚的打印执行3次
    for (int i = 0; i < 3; i++)    //这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止
        System.out.println("伞兵一号卢本伟准备就绪！");   //这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印
}
```

当然，如果要执行多条语句的话，只需要使用花括号囊括就行了：

```java
for (int i = 0; i < 3; i++) {
    System.out.println("伞兵一号卢本伟准备就绪！");
    System.out.println("当前i的值为："+i);
}
```

注意这里的`i`仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了：

![image-20220918112923978](https://s2.loli.net/2022/09/18/2aO9Ro5yfMUvhNc.png)

但是我们可以将`i`的创建放到外面：

```java
public static void main(String[] args) {
    int i = 0;   //在外面创建变量i，这样全部范围内都可以使用了
    for (; i < 3; i++) {   //for循环的三个表达式并不一定需要编写
        System.out.println("伞兵一号卢本伟准备就绪！");
        System.out.println("当前i的值为："+i);
    }
    System.out.println("当前i的值为："+i);
}
```

和之前的`if`一样，for循环同样支持嵌套使用：

```java
public static void main(String[] args) {
    for (int i = 0; i < 3; i++)    //外层循环执行3次
        for (int j = 0; j < 3; j++)    //内层循环也执行3次
            System.out.println("1！5！");
}
```

上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。

实际上，for循环的三个表达式并不一定需要编写，甚至可以三个都不写：

```java
public static void main(String[] args) {
    for (;;)   //如果什么都不写，相当于没有结束条件，这将会导致无限循环
        System.out.println("伞兵一号卢本伟准备就绪！");
}
```

如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）

当然，也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：

```java
public static void main(String[] args) {
    for (int i = 0; i < 3; i++) {
        if(i == 1) continue;   //比如我们希望当i等于1时跳过这一轮，不执行后面的打印
        System.out.println("伞兵一号卢本伟准备就绪！");
        System.out.println("当前i的值为："+i);
    }
}
```

使用`continue`关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行`continue`进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。

在某些情况下，可能希望提前结束循环：

```java
for (int i = 0; i < 3; i++) {
    if(i == 1) break;   //我们希望当i等于1时提前结束
    System.out.println("伞兵一号卢本伟准备就绪！");
    System.out.println("当前i的值为："+i);
}
```

我们可以使用`break`关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。

虽然使用`break`和`continue`关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（**就近原则**）：

```java
for (int i = 1; i < 4; ++i) {
    for (int j = 1; j < 4; ++j) {
        if(i == j) continue;    //当i == j时加速循环
        System.out.println(i+", "+j);
    }
}
```

这里的`continue`加速的对象并不是外层的for，而是离它最近的内层for循环，`break`也是同样的规则：

```java
for (int i = 1; i < 4; ++i) {
    for (int j = 1; j < 4; ++j) {
        if(i == j) break;    //当i == j时终止循环
        System.out.println(i+", "+j);
    }
}
```

那么，要是就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：

```java
outer: for (int i = 1; i < 4; ++i) {   //在循环语句前，添加 标签: 来进行标记
    inner: for (int j = 1; j < 4; ++j) {
        if(i == j) break outer;    //break后紧跟要结束的循环标记，当i == j时终止外层循环
        System.out.println(i+", "+j);
    }
}
```

如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行`break`时会直接跳出整个代码块：

```java
outer: {    //直接对整个代码块打标签
    for (int i = 0; i < 10; i++) {
        if (i == 7) {
            System.out.println("Test");
            break outer;   //执行break时，会直接跳出整个代码块，而不是第一个循环
        }
    }

    System.out.println("？？？");
}
```

虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。



接着来看第二种`while`循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：

```java
while(循环条件) 循环体;
```

相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当`i`大于10时需要结束循环，但是`i`在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。

```java
public static void main(String[] args) {
    int i = 100;   //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确
    while (i > 0) {   //现在唯一知道的是循环条件，只要大于0那么就可以继续除
        System.out.println(i);
        i /= 2;   //每次循环都除以2
    }
}
```

上面的这种情况就非常适合使用while循环。

和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：

```java
public static void main(String[] args) {
    int i = 100;
    while (i > 0) {
        if (i < 10) break;
        System.out.println(i);
        i /= 2;
    }
}
```

也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到`do-while`语句：

```java
public static void main(String[] args) {
    int i = 0;
    do {  //无论满不满足循环条件，先执行循环体里面的内容
        System.out.println("Hello World!");
        i++;
    } while (i < 10);   //再做判断，如果判断成功，开启下一轮循环，否则结束
}
```
